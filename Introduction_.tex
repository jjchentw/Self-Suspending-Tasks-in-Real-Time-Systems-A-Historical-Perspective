\section{Introduction}

In many real-time and embedded systems, tasks may be suspended by the operating system when accessing external devices such as disks, graphical processing units (GPUs), or synchronizing with other tasks in distributed or multicore systems. 
This behavior is often known as \emph{self-suspension}. Self-suspensions are even more pervasive in many emerging embedded cyber-physical systems in which the computation components frequently interact with external and physical devices~\cite{Kang:rtss07,Kato_2011}. Typically, the resulting suspension delays range from a few microseconds (e.g., a write operation on a flash drive~\cite{Kang:rtss07}) to a few hundreds of milliseconds (e.g., offloading computation to GPUs~\cite{Kato_2011,Liu_2014}).

The self-suspending task model~\cite{LA:rtss09} is an useful and widely studied model that can accurately convey the characteristics of many real-time embedded systems that are often seen in practice. The self-suspending task model can be used to represent systems where tasks may experience suspension delays when being blocked to access external devices and shared resources~\cite{Chen:DAC2014, LA:rtas10, LA:rtcsa10, LA:rtss12}. For example, suspension delays introduced by accessing devices such as GPUs could range from a few milliseconds to several seconds~\cite{Kato:rtss11}. 

\textbf{Applications of self-suspending task models and the importance: computation offloading, I/O intensive applications, multicore synchronisations, task-graph scheduling. Giorgio suggested us to point out the wide applications of self-suspending task models.}
  
  