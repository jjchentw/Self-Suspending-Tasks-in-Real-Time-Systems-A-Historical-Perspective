\section{Self-Suspending Tasks in Multiprocessor Synchronizations}
\label{sec:syn}

In this section, we consider the analysis of self-suspensions that arise on multiprocessors under \emph{partitioned fixed-priority (P-FP)} scheduling when tasks synchronize access to shared resources (\eg, shared I/O devices, communication buffers, or scheduler locks) with suspension-based locks (\eg, binary semaphores). Unfortunately, some of the misconceptions surrounding the analysis of self-suspensions on uniprocessors also spread to the analysis of partitioned multiprocessor real-time locking protocols. In particular, as we show with a counterexample, the analysis framework to account for the additional interference due to \emph{remote blocking} first introduced by \cite{lakshmanan-2009}, and reused in several other works~\cite{zeng-2011,bbb-2013,yang-2013,kim-2014,han-2014,carminati-2014,yang-2014},  is flawed. Finally, a straightforward solution for these problems is discussed. 

\subsection{Existing Analysis Strategies}
\label{sec:papers}

P-FP scheduling is a widespread choice in practice due to the wide support in industrial standards such as AUTOSAR, and in many RTOSs like VxWorks, RTEMS, ThreadX, \etc Under P-FP scheduling, each task has a fixed base priority and is statically assigned to a specific processor, and each processor is scheduled independently as a uniprocessor. 

Under partitioned scheduling, a resource accessed by tasks from different processors is called a \emph{global resource}, otherwise it is called a \emph{local resource}. When a job requests a global resource, it may incur \emph{remote blocking} if the global resource is held by a job on another processor. Also, a job may incur \emph{local blocking} if it is prevented from being scheduled by a resource-holding job of a lower-priority task on its local processor. 

Under suspension-based protocols, such as the \emph{multiprocessor priority ceiling protocol (MPCP)}~\cite{rajkumar-1990}, tasks that are denied to access shared resources are suspended. From the perspective of the local schedule on each processor, remote blocking, caused by external events (\ie, resource contention due to tasks on the other processors), pushes the execution of higher-priority tasks to a later time point regardless of the schedule on the local processor (\ie, even if the local processor is idle), and thus may cause additional interference on lower-priority tasks. As a result, remote blocking must be considered as a self-suspension in the analysis. In contrast, local blocking takes place only if a local lower-priority task holds the resource (\ie, if the local processor is busy). Consequently, like in the uniprocessor case, local blocking is accounted for as regular blocking, and not as self-suspension.

A safe yet pessimistic strategy, called \emph{suspension-oblivious analysis}, is to model remote blocking as computation. By overestimating the processor demand of self-suspending, higher-priority tasks, the additional delay due to deferred execution is \emph{implicitly} accounted for as part of regular interference analysis. Block et al.~\cite{block-2007} first used this strategy in the context of partitioned and global \emph{earliest deadline first (EDF)} scheduling; Lakshmanan et al.~\cite{lakshmanan-2009} also adopted this approach in their analysis of ``virtual spinning,'' where tasks suspend when blocked on a lock, but at most one task per processor may compete for a global lock at any time. However, while suspension-oblivious analysis is conceptually straightforward, it can also pessimistically overestimate response times by a factor linear in both the number of tasks and the ratio of the largest and the shortest periods~\cite{wieder-2013}.

A less pessimistic alternative to suspension-oblivious analysis is to \emph{explicitly} bound the effects of deferred execution due to remote blocking. Following this approach, Lakshmanan et al.~\cite{lakshmanan-2009} proposed the following response-time analysis framework that takes into account the amount of remote blocking to bound the worst case interference.

In Eq. \eqref{eqn:wcrt} below, let $B_k^r$ denote an upper bound on the maximum remote blocking that a job of $\tau_k$ incurs, let $C_k^{\ast} = C_k + B_k^r$, and let $\fun{hp(k)}$ and $\fun{lp(k)}$ denote the tasks with higher and lower priority than $\tau_k$, respectively. Furthermore, let $P(\tau_k)$ denote the tasks that are assigned on the same processor as $\tau_k$, and $s_k$ is the maximum number of critical sections of $\tau_k$, and $C_{l,j}^{\prime}$ is an upper bound on the execution time of the $j$\xth critical section of $\tau_l$. It was claimed in \cite{lakshmanan-2009} that, if $R_k^{n+1} = R_k^n \leq D_k$ for some $n > 0$, where $R_k^0 = C_k^{\ast}$ and
\begin{equation}
\label{eqn:wcrt}
R_k^{n+1} = C_k^{\ast} + \sum_{\tau_i \in \fun{hp(k)} \cap P(\tau_k)} \left \lceil \frac{R_k^n + B_i^r}{T_i} \right \rceil \cdot C_i + s_k \sum_{\tau_l \in \fun{lp(k)} \cap P(\tau_k)} \max_{1 \leq j < s_l} C_{l,j}^{\prime}
\end{equation}
then task $\tau_k$ is schedulable and its response time is bounded by $R_k^n$. This  response-time analysis framework~\cite{lakshmanan-2009} was subsequently reused in
\begin{itemize}
\item \cite{zeng-2011} (Equation 9), \cite{han-2014}(Equation 5), and \cite{yang-2014} (Section 2.5) for the MPCP analysis, and
\item \cite{yang-2013} (Equation 6), \cite{bbb-2013} (Equation 1), \cite{carminati-2014} (Equations 3, 12, and 16), and \cite{kim-2014} (Equation 6) to guide the analysis for certain other suspension-based locking protocols.
\end{itemize}

In Eq. \eqref{eqn:wcrt}, the additional interference on $\tau_k$ due to the lock-induced deferred execution of higher-priority tasks is captured by the term ``$+ B^r_i$'' in the interference bound  $\left \lceil \frac{R_k^n + B_i^r}{T_i} \right \rceil \cdot C_i$. This is very similar to the misconception of self-suspending task systems presented in Section~\ref{sec:wrong-jitter-dynamic} by treating the remote blocking as self-suspension. For completeness, we explain why this fails to guarantee a safe response-time bound in certain corner cases by giving a counterexample in the following subsection.

\subsection{A Counterexample}
\label{sec:counterexample}

We show the existence of a schedule in which a task that is considered schedulable according to the analysis in \cite{lakshmanan-2009} is in fact unschedulable.

%\input{counterexample_protocol}

\begin{table}
\centering
    \begin{tabular}{|c|c|c|c|c|c|} 
 \hline
        $\tau_k$ & $C_k$ & $T_k$ ($= D_k$) & $s_k$ & $C_{k,1}^{\prime}$ & Processor\\
        \hline
        $\tau_1$ & 2             & 6  & 0 & $-$ & $1$\\ 
        $\tau_2$ & $4+6\epsilon$ & 13 & 1 & $5\epsilon$& $5$\\
        $\tau_3$ & $\epsilon$    & 14 & 0 & $-$ & $1$\\
        $\tau_4$ & 7             & 14 & 1 & $4-4\epsilon$ & $2$\\ 
        \hline
    \end{tabular}
    \caption{Task parameters for the counter example in Section~\ref{sec:counterexample}.}
    \label{table:parameters}
\end{table}

Consider four implicit deadline sporadic tasks ${\tau_1, \tau_2, \tau_3, \tau_4}$ (with parameters listed in Table \ref{table:parameters}), ordered by a decreasing order of priority, that are scheduled on two processors using P-FP scheduling. Tasks $\tau_1$, $\tau_2$ and $\tau_3$ are assigned to processor 1, while task $\tau_4$ is assigned to processor 2. Each job of $\tau_2$ has a critical section guarded by a global shared resource $\res_1$  ($s_2 = 1$), in which the length of the critical section is at most $5\varepsilon$, $0 < \varepsilon \leq 1/3$, i.e., $C_{2,1}^{\prime} = 5\varepsilon$. 
Each job of $\tau_4$ has a critical section guarded by a global shared resource $\res_1$  ($s_4 = 1$), in which the length of the critical section is at most $4-4\varepsilon$, i.e., $C_{4,1}^{\prime} = 4-4\varepsilon$. 

Consider the response-time of $\tau_3$. Since $\tau_3$ does not access any global resource and it is the lowest-priority task on processor $1$, it does not incur any global or local blocking (\ie, $B_3^r = 0$ and $s_3 \sum_{\tau_l \in \fun{lp}(3) \cap P(\tau_3)} \max_{1 \leq j < s_l} C_{l,j}^{\prime} = 0$). With regard to the remote blocking incurred by each higher-priority task, we have $B_1^r = 0$ because $\tau_1$ does not request any global resource. Further, each time when a job of $T_2$ requests $\res_1$, it may be delayed by $\tau_4$ for a duration of at most $4-4\varepsilon$. Thus the maximum remote blocking of $\tau_2$ is bounded by $B_2^r = C_{4,1}^{\prime} = 4-4\varepsilon$.\footnote{In general, the upper bound on blocking of course depends on the specific locking protocol in use, but in this example, by construction, the stated bound holds under any reasonable locking protocol. Recent surveys of multiprocessor semaphore protocols may be found in \cite{bbb-2013,yang-2015}.} Therefore, according to Eq. \eqref{eqn:wcrt}, we have
\begin{align*}
& R_3^0 = \varepsilon + 0 = \varepsilon, \\
& R_3^1 = \varepsilon + \left \lceil \frac{\varepsilon + 0}{6} \right \rceil \cdot 2 + \left \lceil \frac{\varepsilon + 4 - 4\varepsilon}{13} \right \rceil \cdot (4+6\varepsilon) =  6+7\varepsilon, \\
& R_3^2 = \varepsilon + \left \lceil \frac{6+7\varepsilon + 0}{6} \right \rceil \cdot 2 + \left \lceil \frac{6+7\varepsilon + 4-4\varepsilon}{13} \right \rceil \cdot (4+6\varepsilon) = 8+7\varepsilon, \\
& R_3^3 = \varepsilon + \left \lceil \frac{8+7\varepsilon + 0}{6} \right \rceil \cdot 2 + \left \lceil \frac{8+7\varepsilon + 4-4\varepsilon}{13} \right \rceil \cdot (4+6\varepsilon) = 8+7\varepsilon.
\end{align*}


\begin{figure}[t]
\centering
\def\uxfpga{0.4cm}
\scalebox{0.9}{
\begin{tikzpicture}[x=\uxfpga,y=\uy,auto, thick]
	\draw[->] (-0.4,0) -- coordinate (xaxis) (24,0) node[anchor=north]{$t$};
    \foreach \x in {0,2,...,22}{
         \draw[-,below](\x,0) -- (\x,-0.3) node[] {\pgfmathtruncatemacro\yi{\x} \yi};
    }
    	\foreach \x in {0,1,...,21}{
         \draw[-,very thin,lightgray, dashed](\x,0.3) -- (\x,9.75);
	}	
	\foreach \x in {-0.4,22}{
		\draw[-,thin,gray] (\x,0) -- (\x,2.25);
		\draw[-,thin,gray] (\x,2.7) -- (\x,9.75);
	}
	\foreach \y in {2.25,2.7,9.75}{
		\draw[-,thin,gray] (-0.4,\y) -- (22,\y);
	}
	\foreach \y in {3,5,7}{
		\draw[] (0,\y) -- (22,\y);
	}	
    \node[anchor=east] at (13, 1.5) {Processor 1};
    \node[anchor=east] at (13, 9.25) {Processor 2};

	\begin{scope}[shift={(0,0)}]
	    \node[anchor=east] at (-0.5, 0.5) {$\tau_4$};
		\foreach \x in {1,15}{
			\draw[->] (\x,0) -- (\x,1.75);
        		\node[task7, minimum width=\uxfpga, anchor=south west] at (\x, 0){\footnotesize};         
        		\node[task9, minimum width=3.4*\uxfpga, anchor=south west] at (\x+1, 0){\footnotesize};
        		\draw[] (\x+4.4,1.03)--(\x+6,1.03);
        		\draw[] (\x+6,0)--(\x+6,1.03);
		}
	\end{scope}
        
    \begin{scope}[shift={(0,3)}]
		\node[anchor=east] at (-0.5, 0.5) {$\tau_3$};    
    		\draw[->] (6,0) -- (6,1.75);
    		\draw[<-,red] (20,0) -- (20,1.2);
    		\node[anchor=east,red] at (21, 1.5) {miss};
    	\end{scope}
        
    \begin{scope}[shift={(0,5)}]    
        \node[anchor=east] at (-0.5, 0.5) {$\tau_2$};
        \draw[->] (0,0) -- (0,1.75);
        \draw[->] (13,0) -- (13,1.75);
        \foreach \y in {0.3,0.5,0.7}{
        		\draw[] (2.15,\y) -- (5.5,\y);
        	}
        \draw[] (2,1.03)--(2.15,1.03);
        \draw[] (2.15,0)--(2.15,1.03);
        \draw[] (2,0) -- (2,1.03);
        \node[task9, minimum width=0.1*\uxfpga, anchor=south east] at (6.05, 0){\footnotesize};
        \node[task7, minimum width=4*\uxfpga, anchor=south west] at (8, 0){\footnotesize}; 
        \draw[] (14,1.03)--(14.15,1.03);
        \draw[] (14,0)--(14,1.03);
        \node[task9, minimum width=0.1*\uxfpga, anchor=south west] at (14.15, 0){\footnotesize};
        \draw[] (14.7,1.03)--(18,1.03);
        \draw[] (18,0)--(18,1.03);
        \node[task7, minimum width=0.1*\uxfpga, anchor=south west] at (20, 0){\footnotesize};
	\end{scope}
	
	\begin{scope}[shift={(0,7)}]
        \node[anchor=east] at (-0.5, 0.5) {$\tau_1$}; 
        \foreach \x in {0,6,...,18}{
        		\draw[->] (\x,0) -- (\x,1.75);
		    \node[task7, minimum width=2*\uxfpga, anchor=south west] at (\x, 0){\footnotesize};
		}
	\end{scope}
\end{tikzpicture}}       
\caption{A schedule where $\tau_3$ misses a deadline.}
\label{fig:counterexample_protocol}
\end{figure}

\ifpaper
%\begin{figure}[t]
%  \centering
%  \includegraphics[width=0.85\linewidth]{../figures/Counterexample1/Counterexample1.pdf}
%  \caption{An example schedule where $\tau_3$ misses a deadline.}\label{fig:counterexample_protocol}
%\end{figure}
 \fi

As a result, $R_3 = 8+7\varepsilon < 14 = D_3$, and $\tau_3$ is considered to be schedulable according to the analysis in \cite{lakshmanan-2009}. However, there exists a schedule, shown in Fig. \ref{fig:counterexample_protocol}, which is perfectly legal, where a job of task $\tau_3$  is released at time $6$ and misses its absolute deadline at time $20$. This implies that Eq. \eqref{eqn:wcrt} does not always yield a sound response-time bound. 

The misconception here is to use the remote blocking of each higher-priority task (\ie, $B_i^r$) in a similar way as release jitter. However, it is not sufficient to count the duration of remote blocking as release jitter, as already explained in Section~\ref{sec:wrong-jitter-dynamic}.

\subsection{Incorrect Time Request Analysis With Global Resource Sharing}

A related problem affects an \emph{interface-based analysis}  proposed by \cite{NBN:11}. Targeting \emph{open} real-time systems with globally shared resources (\ie, systems where the final task set composition is not known at analysis time, but tasks may share global resources nonetheless), the goal of the interface-based analysis is to extract a concise abstraction of the constraints that need to be maintained in order  to guarantee the schedulability of all tasks. In particular, the analysis seeks to determine the \emph{maximum tolerable blocking time}, denoted $\fun{mtbt}_k$, that a task $\tau_k$ can tolerate without missing its deadline. 

Recall from classic uniprocessor time-demand analysis \cite{lehoczky-1989} that, \emph{in the absence of jitter or self-suspensions}, a task $\tau_k$ is considered schedulable if
\begin{equation}
\label{eqn:rbf-1}
\exists t \in (0,D_k]: \fun{rbf_{FP}}(k,t) \leq t, 
\end{equation}
where $\fun{rbf_{FP}}(k,t)$ is the \emph{request bound function} of $\tau_k$, which is given by

\begin{equation}
\label{eqn:rbf-2}
\fun{rbf_{FP}} = C_k + B_k + \sum_{\tau_i \in \fun{hp}(k)} \left \lceil \frac{t}{T_i} \right \rceil \cdot C_i.
\end{equation}

Starting from Eq. \eqref{eqn:rbf-1}, Nemati et al.~\cite{NBN:11} first  replaced $\fun{rbf_{FP}}(k,t)$ with its definition, and then substituted  $B_k$ with $\fun{mtbt}_k$. Solving for $\fun{mtbt}_k$ yields:
\begin{equation}
\label{eqn:bloc-tolerate}
\fun{mtbt}_k = \max_{0<t \leq D_k} \left( t - ( C_k + \sum_{\tau_i \in \fun{hp}(k)} \left \lceil \frac{t}{T_i} \right \rceil \cdot C_i ) \right).
\end{equation}

However, based on the example in Section \ref{sec:counterexample}, we can immediately infer that Eq. \eqref{eqn:rbf-1} and Eq. \eqref{eqn:rbf-2}, which ignore the effects of deferred execution due to remote blocking, are unsound in the presence of global locks. Consider $\tau_3$ in the previous example (with parameters listed in Table \ref{table:parameters}). According to Eq. \eqref{eqn:bloc-tolerate}, we have $\fun{mtbt}_3 \geq 12 - (\epsilon + \lceil 12 / 6 \rceil \cdot 2 + \lceil 12 / 13 \rceil \cdot (4+6\epsilon)) = 4-7\epsilon$ (for $t=12$), which implies that $\tau_3$ can tolerate a maximum blocking time of at least $4-7\epsilon$ without missing its deadline. However, this is not true since $\tau_3$ can miss its deadline even without incurring any blocking, as shown in Fig. \ref{fig:counterexample_protocol}. 

\subsection{A Safe Response Time Bound}
\label{sec:safe_bound}

In Eq. \eqref{eqn:wcrt}, the remote blocking of each higher-priority task (\ie, $B_i^r$) is counted in a similar way as release jitter. However, it is not sufficient to count the duration of remote blocking as release jitter, as already explained in Section~\ref{sec:wrong-jitter-dynamic}. A straightforward fix is thus to replace $B_i^r$, in the ceiling function (\ie, the second term in Eq. \eqref{eqn:wcrt}), with a larger value such as $D_i$ (as discussed in Section~\ref{sec:wrong-jitter-dynamic}) or $R_i - C_i$ if $R_i \leq T_i$. Similarly, replacing $\sum_{\tau_i \in \fun{hp}(k)} \lceil t / T_i \rceil \cdot C_i$ in Eq. \eqref{eqn:rbf-2} and Eq. \eqref{eqn:bloc-tolerate} with $\sum_{\tau_i \in \fun{hp}(k)} \lceil (t+D_i) / T_i \rceil \cdot C_i$ or $\sum_{\tau_i \in \fun{hp}(k)} \lceil (t+R_i-C_i) / T_i \rceil \cdot C_i$ can fix the corresponding over-optimistic problem.

Further, since \cite{zeng-2011,bbb-2013,yang-2013,kim-2014,han-2014,carminati-2014,yang-2014} reviewed in Section \ref{sec:papers} merely reused the over-optimistic analysis approach introduced in \cite{lakshmanan-2009} (\ie, reusing $\left \lceil \frac{R_k^n + B_i^r}{T_i} \right \rceil \cdot C_i$ as an interference bound of $\tau_i$ on $\tau_k$), the stated fix as potential solutions may be used to correct the response-time tests in these papers without additional changes.


  
  


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "JRTS/JRTS.tex"
%%% End:


  