\section{Existing Solutions of Self-Suspending Tasks}

This section reviews existing solutions for scheduling and analyzing the schedulability of self-suspending task models. We will first explain the commonly adopted strategies in those solutions. Unfortunately, some of these concepts are incorrect. We will provide concrete reasons and some counterexamples to explain why such misconceptions may lead to over-optimistic analysis. At the end of this section, we will provide the rule of thumb when considering self-suspending task systems. 


\subsection{Common Strategies}

For self-suspending task systems, while executing, a job may suspend itself. While a job suspends, the scheduler removes the job from the ready queue. Such suspensions should be well characterized and the resulting workload interference should be well quantified to analyze the schedulability of the task systems. 

{\bf an example}

There are some common strategies to characterize and quantify the impact due to self-suspensions:
\begin{itemize}
\item {\bf Convert Self-Suspension as Computation:} This is the most simple and the most pessimistic strategy. It basically converts all self-suspending time as computation time. That is, we can consider that the execution time of task $\tau_i$ is always $C_i+S_i$. After the conversion, we only have sporadic tasks. Therefore, all the existing results for sporadic task systems can be adopted. The proof can be done with the following simple interpretation: The suspension of a job may make the processor idle. If two jobs suspend at the same time in the actual schedule, it can be imagined that one of these two jobs have shorter execution time (than its worst-case execution time $C_i+S_i$). Such earlier completion does not affect the schedulability. Therefore, putting $C_i+S_i$ as the worst-case execution time for every task $\tau_i$ is a very safe analysis for both dynamic- and static-scheduling policies.  Such an approach has been widely used as the baseline of more accurate analyses in the literature.

\item {\bf Convert Higher-Priority Tasks to Sporadic Tasks:} In static-priority scheduling, we can convert the higher-priority self-suspending tasks into equivalent sporadic real-time tasks: When we analyze the schedulability of a task $\tau_k$, we can convert the higher-priority self-suspending tasks into sporadic tasks by treating the suspension as computation. That is, a higher-priority task $\tau_i$ (higher than task $\tau_k$) has now worst-case execution time $C_i+S_i$. This simplifies the analysis. After converting, we only have one self-suspending task as the lowest-priority task in the system. Such a conversion is useful for analyzing segmented self-suspending task model. e.g., \cite{LR:rtas10,ecrts15nelissen}. However, such a conversion is not very useful for analyzing dynamic self-suspending task models, since we have to consider the worst case that the self-suspension of task $\tau_k$ makes the processor idle. Therefore, we also have to convert $\tau_k$'s self-suspension as computation. This results in identical analysis by converting self-suspension as computation for all the tasks. 

\item {\bf Quantify Additional Interference due to Self-Suspensions:} Self-suspension may result in more workload from higher-priority jobs to interfere with a lower-priority job. One strategy is to convert the suspension time of a job of task $\tau_k$ under analysis into computation. Suppose that this job under analysis arrives at time $t_k$. The other higher-priority jobs except the job under analysis are considered to have self-suspensions. This is the completely opposite strategy to the first strategy above. Since a higher-priority self-suspending job may suspend itself before $t_k$ and resume after $t_k$, the self-suspending behaviour of a task can be considered to bring \emph{at most} one \emph{carry-in} job to be \emph{partially} executed after $t_k$. As we have converted task $\tau_k$'s self-suspension time as computation, the finishing time of the job of task $\tau_k$ is the earliest moment after $t_k$ such that the processor idles. 
\begin{itemize}
\item In the \emph{dynamic self-suspending task model}, the above analysis implies that the higher-priority jobs arrived after time $t_k$ \emph{should not} suspend themselves to create the maximum interference. Therefore, suppose that the first arrival time of task $\tau_i$ after $t_k$ is $t_i$. Then, the demand of task $\tau_i$ released at time $t \geq t_i$ is $\ceiling{\frac{t-t_i}{T_i} } C_i$. So, we just have to account the demand of the carry-in job of task $\tau_i$ executed between $t_k$ and $t_1$. The workload of the carry-in job can be up to $C_i$, but can also be characterized in a more precise manner. The approaches in this category are presented in \cite{huangpass:dac2015,LiuChen:rtss2014} by greedily counting $C_i$ in the carry-in job. Jane W.S. Liu in her textbook \cite[Page 268-269]{Liu:2000:RS:518501} presents an approach to quantify the higher-priority tasks by setting up the \emph{blocking time} induced by self-suspensions. In her analysis, a job of task $\tau_k$ can suffer from the \emph{extra delay} due to self-suspending behavior as a factor of blocking time, denoted as $B_k$, as follows: (1) The blocking time contributed from task $\tau_k$ is $S_k$. (2) A higher-priority task $\tau_i$ can only block the execution of task $\tau_k$ by at most $b_i=min(C_i, S_i)$ time units. In the textbook \cite{Liu:2000:RS:518501}, the blocking time is then used to perform utilization-based analysis for rate-monotonic scheduling. However, there was no proof in the textbook.

\vspace{0.1in}


Another way to quantify the impact is to model the impact of the carry-in job by using the concept of \emph{jitter}. If the jitter of task $\tau_i$ to model self-suspension is $J_i$, then, the demand of task $\tau_i$ released at time $t+t_k$ is $\ceiling{\frac{t+J_i}{T_i} } C_i$. A safe way it to set $J_i$ to $T_i$, which can be imagined as a pessimistic analysis by assuming that the carry-in job of task $\tau_i$ has execution time $C_i$ and the release time $t_i$ is $t_k$. A more precise way to quantify the jitter is to use the worst-case response time of a higher-priority task $\tau_i$. That is, the jitter $J_i$ of task $\tau_i$ is $R_i-C_i$, where $R_i$ is the worst-case response time of a higher-priority task $\tau_i$ \cite{huangpass:dac2015}. One may quantify the jitter of task $\tau_i$ by setting $J_i$ to $S_i$, which has been adopted in \cite{ECRTS-AudsleyB04,RTAS-AudsleyB04,RTCSA-KimCPKH95}. We will explain later in Section \ref{sec:wrong-jitter} why setting $J_i$ to $S_i$ is in general too optimistic. 

\item In the \emph{segmented self-suspending task model}, we can directly apply all the strategies used to handle dynamic self-suspending task models. However, the analysis will become pessimistic. This is due to the fact that the suspension segments are no longer dynamic. The static suspension patterns result in static suspension pattern. However, characterizing the worst-case suspending patterns of the higher priority tasks to quantify the additional interference under segmented self-suspending task model is not an easy task. Similarly, one possibility is to characterize the worst-case interference in the carry-in job of a higher-priority task $\tau_i$ by analyzing its self-suspending pattern, as presented in \cite{Huang:multiseg}. Another possibility is to  quantify the interference by modeling it with a jitter term, as presented in \cite{RTCSA-BletsasA05}. We will explain later in Section~\ref{sec:wrong-carryin} why the quantification of the interference in \cite{RTCSA-BletsasA05} is incorrect.
\end{itemize}

\item {\bf Enforce Periodic Behaviour by Release Time Enforcement:} 
\end{itemize}


\subsection{Misconceptions in Some Existing Results}
\subsubsection{Incorrect Assumptions in Critical Instant Theorem with Synchronous Releases}
\label{sec:wrong-critical}

\subsubsection{Incorrect Quantifications of Additional Interferences due to Carry-In Jobs}
\label{sec:wrong-carryin}

\subsubsection{Incorrect Quantifications of Jitter}
\label{sec:wrong-jitter}

\subsection{Rule of Thumb When Considering Self-Suspending Systems}
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "authorea_build/authorea_paper.tex"
%%% End:
