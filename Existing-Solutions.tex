
\mychapter{General Design and Analysis Strategies}
\label{sec:review}

Self-suspending task systems have been widely studied in the literature and several solutions have been proposed over the years for 
analyzing their schedulability and building effective suspension-aware scheduling algorithms. In this \mysectionrefnormal{}, we provide an overview of the different 
strategies commonly adopted in the state-of-the-art approaches to analyze and solve the self-suspending task scheduling problem. Although such strategies are
correct in essence, many published results based on those generic analysis frameworks have been corrupted by a set of 
misconceptions which led to incorrect solutions. In an attempt to stop the propagation of erroneous results, a detailed 
description of the various misunderstandings of the self-suspending task model, together with the demonstration of 
counterintuitive results, is provided in \mysectionref{}~\ref{sec:misconceptions}.

%As already introduced in \mysectionref{}~\ref{sec:intro} and exemplified below, the worst-case response time, and hence the schedulability, of a task $\tau_k$ is impacted not only by 
%the possible self-suspension behavior of $\tau_k$ itself, but also by
%the self-suspension behavior of  higher-priority jobs. %As illustrated
%in the example below, this is even possible when task $\tau_k$ is an
%ordinary sporadic task.

%\begin{example}
%\label{ex:taui_ss}
%Let $\tau_2$ be a self-suspending task characterized as follows $((C,S,C),T,D)$ and $\tau_1$ be a non-self-suspending task defined by $(C,T,D)$. Assume that a fixed priority scheduling algorithm is used to schedule those tasks and that $\tau_1$ has a higher priority than $\tau_2$. If one should ignore the self-suspension behavior of $\tau_2$ by assuming an equivalent non-self-suspending task $\tau_2' = (C+C,T,D )$, the worst-case response time of $\tau_2'$ computed with the usual RTA \cite{...} would be .... Yet, as illustrated on Figure~\ref{fig:ex_sched:taui_ss}, the worst-case response time of $\tau_2$ is ... and is obtained when (i) $\tau_2$ experiences its maximum self-suspension time and (ii) $\tau_1$ is synchronously released with the second computation segment of $\tau_2$. 
%\end{example}

%\begin{example}
%\label{ex:tauh_ss} 
%Let $\tau_2$ be an ordinary sporadic task with the following
%attributes $(C_2, T_2, D_2)=(5,10,10)$ and $\tau_1$ be a segmented self-suspending  sporadic
%task defined as $((C_1^1, S_1^1, C_1^2), T_1, D_1)=((1,2,1),8,8)$. Assume that $\tau_2$ and $\tau_1$ are scheduled with a fixed-priority scheduling algorithm on a uniprocessor system
%and that $\tau_1$ has a higher priority than $\tau_2$. If one would ignore the self-suspending behavior of $\tau_1$ by 
%assuming a self-suspending task $\tau_1' = (C_1', T_1', D_1')=(2, 8, 8)$, the worst-case response time of $\tau_2$ computed 
%with the standard response-time analysis (Eq.~\eqref{eq:rta}) would be $R_2 = 7$. However, as illustrated in Figure~\ref{fig:simple-example-suspension},
%due to the self-suspension of $\tau_1$, the actual worst-case response time of 
%$\tau_2$ is $8$ and is obtained when (i) $\tau_1$ experiences its maximum self-suspension time and (ii) $\tau_2$ is 
%synchronously released with the second computation segment of $\tau_1$.
%\hfill\myendproof  
%\end{example}
%
%
%\begin{figure}[t]
%\centering
%\def\uxfpga{0.4cm} 
%\scalebox{1}{
%	\begin{tikzpicture}[x=\uxfpga,y=\uy,auto, thick]
%    \draw[->] (0,0) -- coordinate (xaxis) (15,0) node[anchor=north]{$t$};
%    \draw[] (0,2) -- coordinate (xaxis) (12,2) node[anchor=north]{};
%    \foreach \x in {0,1,...,12}{
%      \draw[-,below](\x,0) -- (\x,-0.3) node[] {\pgfmathtruncatemacro\yi{\x} \yi};
%    }
%    \foreach \x in {0,3,4,8,9,10}{
%      \draw[-,very thin,lightgray, dashed](\x,0.3) -- (\x,4);
%    }	
%    
%    \begin{scope}[shift={(0,0)}]
%      \node[anchor=east] at (0, 0.5) {$\tau_2$};
%      \draw[->] (3,0) -- (3,1.75);
%      \draw[<-,thin,red] (3,1.3) -- (7.5,1.3);
%      \draw[->,thin,red] (8.5,1.3) -- (11,1.3);
%
%
%        \node[task7, minimum width=4*\uxfpga, anchor=south west] at (4, 0){};
%        \node[task7, minimum width=\uxfpga, anchor=south west] at (10, 0){};
%
%      \draw[] (11.05,0) -- (11.05,1.5);
%      \node[anchor=east,red] at (8.5, 1.39) {$8$};
%      \draw[dotted] (11.5,0.5) -- (12.3,0.5); 
%    \end{scope}
%    
%    \begin{scope}[shift={(0,2)}]
%      \node[anchor=east] at (0, 0.5) {$\tau_1$};
%      \foreach \x in {0,8}{ 
%        \draw[->] (\x,0) -- (\x,1.75);        		
%      }
%      \foreach \x in {0,3,8,9}{ 
%        \node[task7, minimum width=\uxfpga, anchor=south west] at (\x, 0){};
%      }
%    \end{scope}                
%  \end{tikzpicture}}
%\caption{Self-suspension can cause substantial schedulability degradation for task $\tau_2$ as shown in Example \ref{ex:tauh_ss}.}
%\label{fig:simple-example-suspension}
%\end{figure}


As to be discussed in details in \mysectionref{}~\ref{sec:hardness}, performing the timing analysis of a set of self-suspending tasks has been proven to be intractable in the general case. For that reason, most work adopts some common strategies to simplify the worst-case response time analysis of self-suspending tasks. Instead of reviewing and summarizing individual research results in the literature, \eg, \cite{Raj:suspension1991,RTCSA-KimCPKH95,MingLiRTCSA1994,PH:rtss98,ECRTS-AudsleyB04,RTAS-AudsleyB04,RTCSA-BletsasA05,LR:rtas10,RTSS-KimANR13,LiuChen:rtss2014,huangpass:dac2015,Huang:multiseg,WC16-suspend-DATE}, we will present the high-level analyses and modeling strategies commonly adopted across those works . Specifically, we will present those strategies in Section~\ref{sec:model-interferred} and Section~\ref{sec:model-interfering} by decoupling the modeling of the task under analysis (\ie, $\tau_2$ in the above example) and the task interfering with the analyzed task, respectively. Table~\ref{tab:summary-methods} provides a summary to show how the methods explained in Section~\ref{sec:model-interferred} and Section~\ref{sec:model-interfering} are linked to the existing results in the literature. 
Moreover, Section~\ref{sec:release-enforce} presents  release enforcement mechanisms to reduce the impact due to self-suspension. 
% in which the links to the existing methods are summarized in Table~\ref{tab:summary-methods-enforcement}. 

We will implicitly assume uniprocessor systems in Sections~\ref{sec:model-interferred},~\ref{sec:model-interfering},~and~\ref{sec:release-enforce}. 
Furthermore, in most cases, we will use fixed-priority scheduling to explain the strategies. Therefore, we implicitly consider the timing analysis for a task $\tau_k$, in which $hp(k)$ is the set of higher-priority tasks, if fixed-priority scheduling is considered. 

Section~\ref{sec:multiprocessor-HRT} will shortly discuss how to handle self-suspending tasks in multiprocessor systems.
% The reasons why some of the results are flawed in Tables~\ref{tab:summary-methods}~and~\ref{tab:summary-methods-enforcement} can be found in Sections~\ref{sec:multiprocessor-HRT}~and~\ref{sec:misconceptions}.




% \begin{table}[t]
%   \centering
%   \scalebox{0.65}{
% \setlength{\extrarowheight}{0.1in}
% \begin{tabular}{||C{2cm}|C{3.3cm}||C{3cm}|C{3cm}|C{3cm}|C{4cm}|}  
%   \hline
%   & &\multicolumn{4}{C{12cm}|}{interfered task ($\tau_k$)} \\
% \cline{3-6}
% & &suspension-oblivious & split & hybrid & critical instant \\
% & &(Sec.~\ref{sec:model-interferred-oblivious}) & (Sec.~\ref{sec:model-interferred:split}) & (Sec.~\ref{sec:model-interferred-hybrid}) & (Sec.~\ref{sec:existing-exact-special}) \\
% \cline{1-6}
% \multirow{5}{*}{\rotatebox[origin=c]{90}{ interferring tasks ($hp(k)$ under FP)}}& 
% suspension-oblivious
% (Sec.~\ref{sec:model-interfering-oblivious}) & used as base-lines in
% many papers & - & - &  Nelissen et al.~\cite[Sec. IV]{ecrts15nelissen}
% (2015), Lakshmanan and Rajkumar~\cite[Sec. III]{LR:rtas10} (2010)\\
% \cline{2-6}
% & carry-in jobs (Sec.~\ref{sec:model-carry-in})& Liu and Chen \cite{LiuChen:rtss2014} (2014), Huang et al. \cite{huangpass:dac2015} (2015)& \multicolumn{2}{l|}{Huang and Chen \cite{Huang:multiseg} (2015)} & -\\
% \cline{2-6}
% & release jitter (Sec.~\ref{sec:model-interfering-jitter})& Ming \cite{MingLiRTCSA1994} (1994), Kim et al. \cite{RTCSA-KimCPKH95}  (1995), Audsley and Bletsas~\cite{ECRTS-AudsleyB04,RTAS-AudsleyB04} (2004)& \multicolumn{2}{L{6cm}|}{Bletsas and Audsley~\cite{RTCSA-BletsasA05} (2005) and  Bletsas~\cite[Chapter 5.4]{bletsas:thesis} (2007)} & Nelissen et al.~\cite[Sec. VI]{ecrts15nelissen} (2015)\\
% \cline{2-6}
% & suspension as blocking (Sec.~\ref{sec:model-interfering-blocking}) &  Liu~\cite[Pages 164-165]{Liu:2000:RS:518501} (2000), Devi \cite[Sec. 4.5]{DBLP:conf/ecrts/Devi03} (2003)& -& - & -\\
% \cline{2-6}
% & segmented~structures (Sec.~\ref{sec:model-interfering-improving}) & - & Palencia and Harbour~\cite{PH:rtss98} (1998, see footnote \ref{footnote-rtss98}) & Bletsas and Audsley~\cite{RTCSA-BletsasA05} (2005), Bletsas~\cite[Chapter 5.4]{bletsas:thesis} (2007),  Huang and Chen \cite{Huang:multiseg} (2015) & -\\
% \hline
% \end{tabular}
% }
%   \caption{Summary of existing methods without any enforcement
%     mechanisms for handling self-suspending tasks in scheduling
%     policies and schedulability
%     analyses. In~\cite[Secs. IV-V]{ecrts15nelissen} and
%     \cite[Sec. III]{LR:rtas10}, the higher-priority tasks are assumed
%     to be ordinary sporadic real-time tasks without any
%     self-suspension. The dynamic self-suspension task model is explicitly considered in  \cite{LiuChen:rtss2014,huangpass:dac2015,MingLiRTCSA1994,RTCSA-KimCPKH95,ECRTS-AudsleyB04,RTAS-AudsleyB04}, \cite[Pages 164-165]{Liu:2000:RS:518501}, and \cite[Sec. 4.5]{DBLP:conf/ecrts/Devi03}. In \cite{PH:rtss98,Huang:multiseg,ecrts15nelissen,LR:rtas10,RTCSA-BletsasA05} and \cite[Chapter 5.4]{bletsas:thesis}, the segmented self-suspension task mode is used. }
%   \label{tab:summary-methods}  
% \end{table}


\begin{table}[h]
  \centering
%\iftechreport%
  \scalebox{0.55}{
%\else%
%  \scalebox{0.65}{%
%\fi
\begin{tabular}{||C{2.5cm}|C{1cm}|C{3cm}||C{5cm}|C{10cm}|}  
  \hline
papers/methods & year & suspension and scheduling model& interfered task ($\tau_k$)& interferring tasks ($hp(k)$ under FP) \\%& flawed? & fixed?\\
\hline
 Ming \cite{MingLiRTCSA1994} & 1994 & dynamic, FP & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & as release jitter, Sec.~\ref{sec:model-interfering-jitter} \\% & X & \checkmark\\
\hline
Kim et al. \cite{RTCSA-KimCPKH95} & 1995 & dynamic, FP & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & as release jitter, Sec.~\ref{sec:model-interfering-jitter} \\%& X & \checkmark\\
\hline
Palencia and Harbour~\cite{PH:rtss98} & 1998 & segmented, FP & split (see footnote \ref{footnote-rtss98}), Sec.~\ref{sec:model-interferred:split}  & segmented structures with dynamic offsets, Sec.~\ref{sec:model-interfering-improving} \\%& &\\
\hline
Liu~\cite[Pages 164-165]{Liu:2000:RS:518501} & 2000 & dynamic, FP & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & as blocking, Sec.~\ref{sec:model-interfering-blocking} \\%& &\\
\hline
Devi \cite[Sec. 4.5]{DBLP:conf/ecrts/Devi03} & 2003 & dynamic, EDF & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & as blocking, Sec.~\ref{sec:model-interfering-blocking} \\%& ? & ?\\ 
\hline
Audsley and Bletsas~\cite{ECRTS-AudsleyB04,RTAS-AudsleyB04} & 2004 & dynamic, FP& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& as release jitter, Sec.~\ref{sec:model-interfering-jitter}  \\%& X& \checkmark\\ 
\hline 
Bletsas and Audsley~\cite{RTCSA-BletsasA05} & 2005 & segmented, FP& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& segmented structures with fixed offsets, Sec.~\ref{sec:model-interfering-improving}\\%& X& \checkmark\\
\hline
Bletsas~\cite[Chapter 5.4]{bletsas:thesis} & 2007 & dynamic or segmented, FP& hybrid, Sec. \ref{sec:model-interferred-hybrid}&segmented structures with fixed offsets, Sec.~\ref{sec:model-interfering-improving} \\%& X & \checkmark\\
\hline 
Lakshmanan and Rajkumar~\cite{LR:rtas10} & 2010 & segmented, FP&
revised critical instant, Sec.~\ref{sec:existing-exact-special} &
(only ordinary sporadic tasks) \\%&X & \checkmark\\
\hline
Liu and Anderson~\cite{DBLP:conf/ecrts/LiuA13} & 2013 & multiprocessor, global FP and EDF &  suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& carry-in jobs in multiprocessor scheduling, Sec.~\ref{sec:multiprocessor-HRT} \\%& X&\checkmark\\
\hline 
Liu et al. \cite{DBLP:conf/ecrts/LiuCH014} & 2014 & dynamic, FP (harmonic)& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& no additional impact due to self-suspension\\%& &\\ 
\hline 
Liu and Chen~\cite{LiuChen:rtss2014} & 2014 & dynamic, FP& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& as carry-in, Sec.~\ref{sec:model-carry-in}\\% & &\\
\hline
Huang and Chen \cite{Huang:multiseg}& 2015 & segmented, FP& hybrid, Sec.~\ref{sec:model-interferred-oblivious}-~\ref{sec:model-interferred-hybrid} & segmented structures with dynamic offsets, Sec.~\ref{sec:model-interfering-improving}\\%& & \\
\hline
Huang et al.~\cite{huangpass:dac2015} & 2015 & dynamic, FP& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& as carry-in,  Sec.~\ref{sec:model-carry-in}\\%&&\\
\hline
Nelissen et al.~\cite{ecrts15nelissen} & 2015 & segmented, FP & based on a revised critical instant, Sec.~\ref{sec:existing-exact-special} & suspension by modeling proper release jitter (Sec.~\ref{sec:model-interfering-jitter}) and enumerating the worst-case interferences\\%&&\\
\hline
Chen et al.~\cite{ChenECRTS2016-suspension} & 2016 & dynamic, FP & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & a unifying framework based on more precise release jitter, Sec.~\ref{sec:model-interfering-unified}\\%&&\\
\hline
\end{tabular}
}

\vspace{0.25in}
%\iftechreport%
  \scalebox{0.55}{%
%\else%
%  \scalebox{0.65}{%
%\fi
%\setlength{\extrarowheight}{0.1in}
\begin{tabular}{||C{0.5cm}|C{3.3cm}||C{3cm}|C{3cm}|C{3cm}|C{5cm}|}  
\cline{3-6}
\multicolumn{2}{c|}{}  &\multicolumn{4}{C{12cm}|}{interfered task ($\tau_k$)} \\
\cline{3-6}
\multicolumn{2}{c|}{}  &suspension-oblivious & split & hybrid & critical instant \\
\multicolumn{2}{c|}{}  &(Sec.~\ref{sec:model-interferred-oblivious}) & (Sec.~\ref{sec:model-interferred:split}) & (Sec.~\ref{sec:model-interferred-hybrid}) & (Sec.~\ref{sec:existing-exact-special}) \\
\cline{1-6}
& 
suspension-oblivious
(Sec.~\ref{sec:model-interfering-oblivious}) & used as base-lines in
many papers & - & - &~\cite[Sec. III]{LR:rtas10}, \cite[Sec. IV]{ecrts15nelissen}
(footnote ~\ref{footnote-critical-instant})\\
\cline{2-6}
\multirow{4}{*}{\rotatebox[origin=c]{90}{ interferring tasks}}& carry-in jobs (Sec.~\ref{sec:model-carry-in})& \cite{LiuChen:rtss2014}, \cite{huangpass:dac2015}& \multicolumn{2}{c|}{\cite{Huang:multiseg}} & -\\
\cline{2-6}
& release jitter (Sec.~\ref{sec:model-interfering-jitter}, Sec.~\ref{sec:model-interfering-unified})&
\cite{MingLiRTCSA1994},
\cite{RTCSA-KimCPKH95},~\cite{ECRTS-AudsleyB04} \cite{RTAS-AudsleyB04}& \multicolumn{2}{c|}{\cite{RTCSA-BletsasA05}, \cite[Chapter 5.4]{bletsas:thesis}} &\cite{ChenECRTS2016-suspension},\cite[Sec. VI]{ecrts15nelissen}\\
\cline{2-6}
& suspension as blocking (Sec.~\ref{sec:model-interfering-blocking}) &  \cite[Pages 164-165]{Liu:2000:RS:518501}, \cite[Sec. 4.5]{DBLP:conf/ecrts/Devi03}& -& - & -\\
\cline{2-6}
& segmented~structures (Sec.~\ref{sec:model-interfering-improving}) &
- & \cite{PH:rtss98} (footnote \ref{footnote-rtss98}) & \cite{RTCSA-BletsasA05}, \cite[Chapter 5.4]{bletsas:thesis}, \cite{Huang:multiseg} & -\\
\hline
\end{tabular}
}
  \caption{Summary of existing methods without any enforcement
    mechanisms for handling self-suspending tasks in scheduling
    policies and schedulability analyses. } 
  \label{tab:summary-methods}
\end{table}


% \begin{table}[t]
%   \centering
%   \scalebox{0.65}{
% \begin{tabular}{||C{2.5cm}|C{1cm}|C{3cm}||C{5cm}|C{5cm}|c|c|}  
%   \hline
% papers/methods & year & suspension and scheduling model& interfered task ($\tau_k$)& interferring tasks ($hp(k)$ under FP) & flawed? & fixed?\\
% \hline
%  Ming \cite{MingLiRTCSA1994} & 1994 & dynamic, FP & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & as release jitter, Sec.~\ref{sec:model-interfering-jitter} & X & \checkmark\\
% \hline
% Kim et al. \cite{RTCSA-KimCPKH95} & 1995 & dynamic, FP & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & as release jitter, Sec.~\ref{sec:model-interfering-jitter} & X & \checkmark\\
% \hline
% Palencia and Harbour~\cite{PH:rtss98} & 1998 & segmented, FP & split (see footnote \ref{footnote-rtss98}), Sec.~\ref{sec:model-interferred:split}  & segmented structures with dynamic offsets, Sec.~\ref{sec:model-interfering-improving} & &\\
% \hline
% Liu~\cite[Pages 164-165]{Liu:2000:RS:518501} & 2000 & dynamic, FP & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & as blocking, Sec.~\ref{sec:model-interfering-blocking} & &\\
% \hline
% Devi \cite[Sec. 4.5]{DBLP:conf/ecrts/Devi03} & 2003 & dynamic, EDF & suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious} & as blocking, Sec.~\ref{sec:model-interfering-blocking} & ? & ?\\ 
% \hline
% Audsley and Bletsas~\cite{ECRTS-AudsleyB04,RTAS-AudsleyB04} & 2004 & dynamic, FP& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& as release jitter, Sec.~\ref{sec:model-interfering-jitter}  & X& \checkmark\\ 
% \hline 
% Bletsas and Audsley~\cite{RTCSA-BletsasA05} & 2005 & segmented, FP& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& segmented structures with dynamic offsets, Sec.~\ref{sec:model-interfering-improving}& X& \checkmark\\
% \hline
% Bletsas~\cite[Chapter 5.4]{bletsas:thesis} & 2007 & dynamic or segmented, FP& hybrid, Sec. \ref{sec:model-interferred-hybrid}&segmented structures with dynamic offsets, Sec.~\ref{sec:model-interfering-improving} & X & \checkmark\\
% \hline 
% Lakshmanan and Rajkumar~\cite{LR:rtas10} & 2010 & segmented, FP& revised critical instant, Sec.~\ref{sec:existing-exact-special} & revised critical instant &X & \checkmark\\
% \hline
% Liu and Anderson~\cite{DBLP:conf/ecrts/LiuA13} & 2013 & multiprocessor, global FP and EDF &  suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& carry-in jobs in multiprocessor scheduling, Sec.~\ref{sec:multiprocessor-HRT} & X&\checkmark\\
% \hline 
% Liu et al. \cite{DBLP:conf/ecrts/LiuCH014} & 2014 & dynamic, FP (harmonic)& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& no additional impact due to self-suspension& &\\ 
% \hline 
% Liu and Chen~\cite{LiuChen:rtss2014} & 2014 & dynamic, FP& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& as carry-in, Sec.~\ref{sec:model-carry-in} & &\\
% \hline
% Huang and Chen \cite{Huang:multiseg}& 2015 & segmented, FP& hybrid, Sec.~\ref{sec:model-interferred-oblivious}-~\ref{sec:model-interferred-hybrid} & segmented structures with dynamic offsets, Sec.~\ref{sec:model-interfering-improving}& & \\
% \hline
% Huang et al.~\cite{huangpass:dac2015} & 2015 & dynamic, FP& suspension-oblivious, Sec.~\ref{sec:model-interferred-oblivious}& as carry-in,  Sec.~\ref{sec:model-carry-in}&&\\
% \hline
% Nelissen et al.~\cite{ecrts15nelissen} & 2015 & segmented, FP & based on a revised critical instant, Sec.~\ref{sec:existing-exact-special} & suspension by modeling proper release jitter (Sec.~\ref{sec:model-interfering-jitter}) and enumerating the worst-case interferences&&\\
% \hline
% \end{tabular}
% }
%   \caption{Summary of existing methods without any enforcement mechanisms for handling self-suspending tasks in scheduling policies and schedulability analyses.}
%   \label{tab:summary-methods}
% \end{table}

% \begin{table}
% \centering
% \scalebox{0.65}{
% \begin{tabular}{||C{2.5cm}|C{1cm}|C{3cm}||C{9cm}|c|c|}  
%   \hline
% papers/methods & year & suspension and scheduling model & enforcement & flawed? & fixed?\\
% \hline 
% Rajkumar \cite{Raj:suspension1991} & 1991 & segmented, FP &
% A period enforcer algorithm was proposed to artificially 
% increase certain suspension intervals so that the self-suspending tasks behave like ideal periodic tasks, Sec.~\ref{sec:period-enforce} & &\\
% \hline 
% Ding et al.\cite{DBLP:journals/ieicet/DingTT09} & 2009 &segmented, segmented FP & 
% enforcement for each computation segment, Sec.~\ref{sec:static-period-enforce} & X & ?\\
% \hline 
% Lakshmanan and Rajkumar~\cite{LR:rtas10} & 2010 & segmented, FP& slack enforcement, Sec.~\ref{sec:slack-enforce}& ? & ?\\
% \hline
% Kim et al.~\cite{RTSS-KimANR13} & 2013 & segmented, segmented FP & enforcement for each computation segment, Sec.~\ref{sec:static-period-enforce} & X & ?\\
% \hline
% Chen and Liu~\cite{RTSS-ChenL14} & 2014 & segmented (one-segment), period enforcement&  speedup factor guarantee w.r.t. the optimal schedule, Sec.~\ref{sec:static-period-enforce}&&\\
% \hline
% Huang et al.~\cite{WC16-suspend-DATE} & 2016 & segmented, period enforcement& speedup factor guarantee w.r.t. the optimal schedule, Sec.~\ref{sec:static-period-enforce}&&\\
% \hline
% \end{tabular}
% }
%   \caption{Summary of existing methods with  certain enforcement mechanisms for handling self-suspending tasks in scheduling policies and schedulability analyses.}
%   \label{tab:summary-methods-enforcement}
% \end{table}

\mysection{Modeling the Interfered Task}
\label{sec:model-interferred}

Two main strategies have been proposed in the literature to simplify the modeling of a self-suspending task $\tau_k$ during its schedulability test or worst-case response time analysis:
\begin{itemize}
\item the suspension-\emph{oblivious} approach, which models the suspension intervals of $\tau_k$ as if they were usual execution time (Section~\ref{sec:model-interferred-oblivious});
\item the \emph{split} approach, which computes the worst-case response time of each computation segment of $\tau_k$ as if they were independent tasks (Section~\ref{sec:model-interferred:split}).
\end{itemize}
Strategies combining both approaches have also been investigated and are discussed in Section~\ref{sec:model-interferred-hybrid}.
 To the best of the authors' knowledge, to date, no tractable solution has been found to compute the exact worst-case interference suffered by a segmented self-suspending task. 




\mysubsection{Modeling suspension as computation}
\label{sec:model-interferred-oblivious}

This strategy is often referred to as the \emph{suspension-oblivious} approach in the literature, but sometimes also called ``joint'' \cite{bletsas:thesis}. It assumes that the self-suspending task $\tau_k$ continues executing on the processor when it self-suspends. Its suspension intervals are thus considered as being preemptible. From an analysis perspective, it is equivalent to replacing the self-suspending task $\tau_k$ by an ordinary sporadic (non-self-suspending) task $\tau_k'$ with worst-case execution time equal to $C_k + S_k$ and the same relative deadline/period as those of task $\tau_k$, \ie, a three-tuple $(C_k+S_k, T_k, D_k)$. 

%Since the suspension intervals are assumed to be preemptible
Converting the suspension time of task $\tau_k$ into computation time can become very pessimistic for \emph{segmented} self-suspending tasks. This is especially true when (i) its total self-suspension time $S_k$ is much larger than its worst-case execution time $C_k$ and/or (ii) the lengths of $\tau_k$'s suspension intervals are larger than the periods of (some of) the interfering tasks. 

\begin{example}
\label{ex:suspension-as-comput}   
Consider the task set in Table~\ref{table:static-example} under FP scheduling. Task $\tau_3$ would be transformed into a non-self-suspending task $\tau_3'=(7,15,15)$. Task $\tau_3'$ is obviously not schedulable since the total utilization of $\tau_1$, $\tau_2$ and $\tau_3'$ is given by $\frac{2}{5} + \frac{2}{10} + \frac{7}{15} = \frac{16}{15} > 1$. Yet, the self-suspending task $\tau_3$ is schedulable as it will be shown in Section~\ref{sec:model-interferred:split}.
\hfill\myendproof  
\end{example}

Nevertheless, for some cases, this modeling strategy is an \emph{exact} solution to compute the WCRT of \emph{dynamic} self-suspending tasks under fixed-priority scheduling. If the computation segments and suspension intervals of $\tau_k$ interleave such that $\tau_k$ self-suspends only between the arrival of higher-priority jobs
(\ie,  a computation segment of $\tau_k$ is started whenever a higher-priority job is released), then the resulting schedule would be similar if $\tau_k$ was indeed executing on the processor during its self-suspensions. Therefore, when there is no knowledge about how many times, when, and for how long $\tau_k$ may self-suspend in each 
self-suspension interval, modeling the self-suspension time of $\tau_k$ as execution time provides the exact worst-case response 
time for $\tau_k$ under FP scheduling. 

For example, Theorem 3 in \cite{huangpass:dac2015} provides the following necessary condition for any fixed-priority scheduling: 

\emph{ If there exists a feasible fixed-priority preemptive scheduling
  algorithm, then, for each task $\tau_k$, there exists $t$ with $0 < t \leq D_k$ such that}
  \begin{equation}
    \label{eq:necessary-fp-scheduling}
    C_k+S_k + \sum_{\tau_i \in
      hp(k)} \ceiling{\frac{t}{T_i}}C_i   \leq t,
  \end{equation}
\emph{where $hp(\tau_k)$ is the set of the tasks with higher-priority levels than task $\tau_k$.} 

Eq.~(\ref{eq:necessary-fp-scheduling}) is an exact analysis if $D_k \leq T_k$ and all the tasks in $hp(k)$ are ordinary sporadic real-time tasks without any suspensions. By Eq.~(\ref{eq:necessary-fp-scheduling}), it is necessary to model the suspension time of the task under analysis as computation time if we consider dynamic self-suspending tasks under fixed-priority scheduling. Such a modeling strategy to consider suspension as computation for the task under analysis is widely used in all the existing analyses for the dynamic self-suspension task model under fixed-priority scheduling, \eg, \cite{LiuChen:rtss2014,huangpass:dac2015,MingLiRTCSA1994,RTCSA-KimCPKH95,RTAS-AudsleyB04,ECRTS-AudsleyB04,Liu:2000:RS:518501} (see Table~\ref{tab:summary-methods}, in which some multiprocessor cases from \cite{DBLP:conf/ecrts/LiuA13,DBLP:conf/ecrts/LiuCH014} are also covered). However, such a modeling strategy is not always exact for the dynamic self-suspension task model if other scheduling strategies (instead of fixed-priority scheduling) are applied.


%This is the simplest and the most pessimistic strategy. It converts all self-suspension time into computation time. Such a strategy is also referred to as \emph{suspension-oblivious} analysis in the literature. That is, we can consider the execution time of task $\tau_i$ to be $C_i+S_i$. After this conversion, we only have ordinary sporadic real-time tasks. Therefore, all the existing results for sporadic task systems can be applied. %The proof can be done with the following simple interpretation: The suspension of a job may make the processor idle. If two jobs suspend at the same time and the processor idles in a certain time interval in the actual schedule, it can be imagined that one of these two jobs has shorter execution time (than its worst-case execution time $C_i+S_i$). Such earlier completion does not affect the schedulability analysis. Therefore, putting $C_i+S_i$ as the worst-case execution time for every task $\tau_i$ is a very safe analysis for both dynamic- and static-scheduling policies.  Such an approach has been widely used as the baseline of more accurate analyses in the literature.

%With this schedulability test, it is easy to see that none of the example task sets can be classified as feasible since $\frac{1}{2} + \frac{5+5}{20} + \frac{1}{D_\gamma} > 1$ and $\frac{2}{5}+\frac{2}{10}+\frac{1+5+1}{15} > 1$.

\mysubsection{Modeling each computation segment as an independent task}
\label{sec:model-interferred:split}

An alternative is to individually compute the WCRT of each of the computation segments of task $\tau_k$ \cite{bletsas:thesis,PH:rtss98,Huang:multiseg}.\footnote{\label{footnote-rtss98}It was not explicitly explained in \cite{PH:rtss98} how to model the task under analysis. Our interpretation was based on the conditions in Eq.(36) and Eq.(37) in \cite{PH:rtss98}.}
The WCRT of $\tau_k$ is then upper-bounded by the sum of the segments' worst-case response times added to $S_k$, the maximum length of the overall
self-suspension intervals. 
 
Let $R_k^j$ denote the worst-case response time of the computation segment $C_k^j$. The schedulability test for task $\tau_k$ succeeds if $\sum_{j=1}^{m_k} R_k^j + \sum_{j=1}^{m_k-1} S_k^j \leq D_k $. 

\begin{table}[t]
\centering
    \begin{tabular}{|c|c|c|c|}
 \hline
        & $(C_i^1, S_i^2, C_i^2)$ &  $D_i$ & $T_i$\\ 
        \hline
        $\tau_1$ & (2, 0, 0) &  5 & 5\\ 
        $\tau_2$ &  (2, 0, 0) & 10 & 10 \\ 
        $\tau_3$ & (1, 5, 1) & 15  & 15\\
%        $\tau_4$ & (3, 0, 0) & ? & $\infty$\\
        \hline
    \end{tabular} 
    \caption{A segmented self-suspending task set, used in Examples~\ref{ex:suspension-as-comput} and \ref{ex:suspension-as-split-1}, to compare the suspension-oblivious and split approaches.}
    \label{table:static-example}
\end{table}

\begin{example}
\label{ex:suspension-as-split-1}   
Consider the task set presented in Table~\ref{table:static-example}. The usual RTA for fixed-priority sporadic real-time tasks without self-suspension \cite{Liu_1973} tells us that the WCRT of a task $\tau_k$ is upper bounded by the smallest positive solution of $R_k$, satisfying the condition that
  \begin{equation}
   \label{eq:rta}
  R_k = C_k+ \sum_{\tau_i \in hp(k)}\ceiling{\frac{R_k}{T_i}} C_i,     
  \end{equation}
  where $hp(k)$ is the set of the tasks with higher-priorities
  than $\tau_k$.

Therefore, the WCRT of $C_3^1$ and $C_3^2$ are both $5$. Hence, we know that the WCRT of task $\tau_3$ is at most $R_3^1 + R_3^2 + S_3 = 5 + 5 + 5 = 15$.
\hfill\myendproof  
\end{example}

The above test can be fairly pessimistic, especially when $S_k$ is short. 
\begin{example}
\label{ex:suspension-as-split-2}   
Consider the same task set presented in Example~\ref{ex:suspension-as-split-1} by decreasing $S_3$ from $5$ to $1$. This analysis still considers that both computation segments suffer from the worst-case interference from the two higher-priority tasks. It then returns $R_3^1 + R_3^2 + S_3 = 5 + 5 + 1 =11$ as the (upper bound on the) worst-case response time of $\tau_3$. Yet the suspension-oblivious approach discussed in Section~\ref{sec:model-interferred-oblivious} shows that the worst-case response time of $\tau_3$ is at most $9$.
\hfill\myendproof  
\end{example} 

This strategy is not widely used alone, but can be used as part of hybrid approaches, explained as follows.

\mysubsection{Hybrid approaches}
\label{sec:model-interferred-hybrid}

Both methods discussed in Sections~\ref{sec:model-interferred-oblivious} and~\ref{sec:model-interferred:split} have their pros and cons. The \emph{joint} (\ie, \emph{suspension-oblivious}) approach has the advantage of
respecting the minimum inter-arrival times (or periods) of the higher-priority tasks during the schedulability 
analysis of $\tau_k$. However, it has the disadvantage of assuming that the task under analysis can be delayed by preemptions during suspension intervals since they are treated as computation intervals. 
This renders the analytical pessimism as it accounts for non-existing interference. The \emph{split} approach does not assume  
preemptible suspension intervals but  considers a worst-case response time for each computation segment independently. Yet, the respective
release patterns of interfering tasks leading to the worst-case response time of each computation segment may not be compatible with each other.

As shown with the above examples, the joint and split approaches are not comparable in the sense that none 
of them dominates the other. Yet, since both provide an upper bound on the worst-case response time of $\tau_k$, one can 
simply take the minimum response time value obtained with any of them. However, as proposed in \cite[Chapter 5.4]{bletsas:thesis} and \cite{Huang:multiseg}, 
it is also possible to combine their respective advantages and hence reduce the overall pessimism of the analysis. 
The technique proposed in \cite{bletsas:thesis}, for tasks of the \emph{segmented} model,
consists in dividing the self-suspending task $\tau_k$ (that is under analysis) into several blocks of consecutive 
computation segments. The suspension intervals between computation segments pertaining to the same block are modeled as execution time 
like in the ``joint'' approach. The suspension intervals situated between blocks are ``split''. The worst-case response time is then computed for each 
block independently and $\tau_k$'s WCRT is upper-bounded by the sum of the block's WCRTs added to the length of the split suspension 
intervals. This provides a tighter bound on the WCRT, especially if we consider all possible block sequence decompositions of $\tau_k$, which has exponential-time complexity. 
%It is clearly a process with exponential time complexity.
% It was however shown to be applicable to task systems of realistic sizes.

\mysubsection{Exact schedulability analysis}
\label{sec:existing-exact-special}

As already mentioned in Section~\ref{sec:model-interferred-oblivious}, under fixed-priority scheduling, the suspension-oblivious approach is an exact analysis for dynamic 
self-suspending tasks assuming that there is only one self-suspending task $\tau_k$ and all the interfering tasks do not self-suspend. 
There is no work providing an exact schedulability analysis for any other cases under the dynamic self-suspending task model.

The problem of the schedulability analysis of segmented self-suspending tasks has been treated in~\cite{LR:rtas10,ecrts15nelissen}, 
again assuming only one self-suspending task $\tau_k$. The proposed solutions are based on the notion of the critical instant.\footnote{\label{footnote-critical-instant}In~\cite[Secs. IV-V]{ecrts15nelissen} and
    \cite[Sec. III]{LR:rtas10}, the higher-priority tasks are assumed
    to be ordinary sporadic real-time tasks without any
    self-suspension.}
That is, they aim to find an instant at which, considering the state of the system, an execution request for $\tau_k$ will 
generate the largest response time. Unfortunately, the analysis in \cite{LR:rtas10} has been proven to be flawed in~\cite{ecrts15nelissen}. 
Further details are provided in Section~\ref{sec:wrong-critical}. It has been recently shown by Chen \cite{RTSS2016-suspension}
that the schedulability analysis for FP scheduling (even with only one segmented self-suspending
task as the lowest-priority task) is $co{\cal NP}$-hard in the strong
sense when there are at least two self-suspension intervals in task $\tau_k$.




\mysection{Modeling the Interfering Tasks}
\label{sec:model-interfering}

After presenting how to model the interfered self-suspending task, \ie, task $\tau_k$, we will summarize the existing analyses for modeling the interfering tasks. For analyzing the interfering tasks in the dynamic self-suspending task model, we classify the existing approaches into 
\begin{itemize}
\item suspension-oblivious analysis in Section~\ref{sec:model-interfering-oblivious}, 
\item interference analysis based on carry-in jobs in Section~\ref{sec:model-carry-in},
\item interference analysis based on release jitter in Section~\ref{sec:model-interfering-jitter},
\item modeling self-suspensions as blocking in Section~\ref{sec:model-interfering-blocking}, and
\item unifying interference analysis based on more precise jitter in Section~\ref{sec:model-interfering-unified}.
\end{itemize}
Since the dynamic self-suspending task model is more general than the segmented self-suspending task model, any schedulability analysis and scheduling algorithms that can be used for the dynamic self-suspending task model can also be applied to the segmented self-suspending task model. However, ignoring the known segmented suspension structures can also be too pessimistic, as explained in \mysectionref{}~\ref{sec:model}. We will explain in Section~\ref{sec:model-interfering-improving} how to account for the workload from the interfering tasks more precisely by exploiting the segmented self-suspension structure.

\mysubsection{Suspension-oblivious analysis}
\label{sec:model-interfering-oblivious}

Similarly to the task under analysis, the simplest modeling strategy for the interfering tasks is the suspension-oblivious approach, which converts all the suspension times of those tasks into computation times. Each task $\tau_i$ is thus modeled by a non-self-suspending task $\tau_i' = (C'_i, D_i, T_i)$ with a WCET $C'_i = C_i+S_i$. After that conversion, the interfering tasks therefore become a set of ordinary non-self-suspending sporadic real-time tasks. Although the simplest, it is also the most pessimistic approach. It indeed considers that the suspension intervals of each interfering task $\tau_i$ are causing interference on the task $\tau_k$ under analysis. Yet, suspension intervals truly model durations during which $\tau_i$ stops executing on the processor and hence cannot prevent the execution of $\tau_k$ or any other lower-priority job.


\mysubsection{Modeling self-suspensions with carry-in jobs}
\label{sec:model-carry-in}

If all the higher-priority jobs/tasks are ordinary sporadic jobs/tasks without any self-suspensions, then
the maximum number of interfering jobs that can be released by an interfering (ordinary) sporadic task $\tau_i$ in a window of length $t$, is upper bounded by $\left\lceil \frac{t}{T_i} \right\rceil$ in fixed-priority scheduling and by $\left\lfloor \frac{t}{T_i} \right\rfloor$ in EDF scheduling. The interfering workload is then given by $\sum_{\forall \tau_i \in hp(k)} \left\lceil \frac{t}{T_i} \right\rceil C_i$ for fixed priority scheduling and by $\sum_{\forall \tau_i \in \tau \setminus \tau_k} \left\lfloor \frac{t}{T_i} \right\rfloor C_i$ for EDF scheduling. This assumes that each interfering job asks for the processor as soon as it is released, thereby preventing the task $\tau_k$ under analysis from executing.

With self-suspending tasks however, the \emph{computation segment} of an interfering job may not require an immediate access to the processor as it can be delayed by its suspension intervals. Hence, a job of task $\tau_i$ released before the release of a job of task $\tau_k$ may have all its execution time $C_i$ delayed by its suspension intervals to entirely interfere with $\tau_k$. 
This is clearly visible on the example schedule of Figure~\ref{fig:ss-intuition}(b), when $\tau_2$ is the task under analysis.
Such a job of $\tau_i$ (\eg, second job of task $\tau_1$ in Figure~\ref{fig:ss-intuition}(b)), which is released before the job of $\tau_k$ under analysis, but interfering with the execution of $\tau_k$, is called a \emph{carry-in job}.

In the worst case, each interfering task $\tau_i$ releases one carry-in job (assuming that they all respect their deadlines and that $D_i \leq T_i$). This extra-workload, which can be up to $C_i$, has been integrated in the schedulability test for self-suspending tasks in \cite{huangpass:dac2015,LiuChen:rtss2014} (see Table~\ref{tab:summary-methods}) by greedily adding one interfering job to the interfering workload released by each task $\tau_i$.


%In the \emph{dynamic self-suspending task model}, the above analysis implies that the higher-priority jobs arrived after time $t_k$ \emph{should not} suspend themselves to create the maximum interference. Therefore, suppose that the first arrival time of task $\tau_i$ after $t_k$ is $t_i$, \ie, $t_i \geq t_k$. Then, the demand of task $\tau_i$ released at time $t \geq t_i$ is $\left\lceil \frac{t-t_i}{T_i} \right\rceil C_i$. So, we just have to account for the demand of the carry-in job of task $\tau_i$ executed between $t_k$ and $t_i$. The workload of the carry-in job can be up to $C_i$ (due to the assumption $D_i \leq T_i$), but can also be characterized in a more precise manner. The approaches in this category are presented in \cite{huangpass:dac2015,LiuChen:rtss2014} by greedily counting $C_i$ in the carry-in job. 


\mysubsection{Modeling self-suspensions as release jitter}
\label{sec:model-interfering-jitter}

A more accurate way to model the phenomena described above is to use the concept of \emph{release jitter}, \eg, in \cite{ecrts15nelissen,BletsasReport2015,huangpass:dac2015,Raj:suspension1991,ECRTS-AudsleyB04,RTAS-AudsleyB04,RTCSA-KimCPKH95}.
 It basically considers 
that the computation segments of each task $\tau_i$ are not released in a purely periodic manner but are instead subject to release jitter. 
Hence the first interfering job of $\tau_i$ may have its computation segment pushed as far as possible from the actual release of the job 
due to its suspension behavior, while all the jobs released afterward may directly start with their computation segments and never 
self-suspend (see task $\tau_1$ in Figure~\ref{fig:ss-intuition} for a simple example or task $\tau_2$ in Figure~\ref{fig:counterexample-dynamic} in \mysectionref{}~\ref{sec:misconceptions} for a more complicated example). Let $J_i$ denote that jitter on $\tau_i$'s computation segment release. 
It was proven in \cite{ecrts15nelissen,BletsasReport2015} that $J_i$ is upper-bounded by $R_i-C_i$ where $R_i$ is the WCRT of $\tau_i$. 
If an optimal priority assignment must be computed for a fixed-priority task set using Audsley's optimal priority assignment 
algorithm~\cite{Audsley1991aOPA}, one can pessimistically assume that $J_i$ is equal to $D_i-C_i$ \cite{huangpass:dac2015,Raj:suspension1991} 
as long as all the interfering tasks, \ie, $\forall \tau_i \in hp(k)$ in fixed-priority scheduling, are schedulable, \ie, $R_i \leq D_i$.


\begin{table}[t]
\centering
    \begin{tabular}{|c|c|c|c|c|}
 \hline
        & $C_i$ &  $S_i$&  $D_i$ & $T_i$\\ 
        \hline
        $\tau_1$ & 1 & 0 &  2 & 2\\ 
        $\tau_2$ &  5&  5& 20 & 20 \\ 
        $\tau_3$ & 1 & 0  & 50 & $\infty$ \\ 
        \hline
    \end{tabular} 
    \caption{A dynamic self-suspending task set used in Examples~\ref{ex:suspension-jitter} and~\ref{ex:suspension-blocking} for illustrating the methods by modelling suspensions as release jitter and blocking.}
    \label{table:dynamic-example}
\end{table}

By adopting the suspension-oblivious modeling in Section~\ref{sec:model-interferred-oblivious} for task $\tau_k$ in a fixed-priority task set under the dynamic self-suspension model, the WCRT of $\tau_k$ is upper bounded by the least non-negative value $R_k \leq D_k$ such that 
\begin{equation*}
R_k=C_k+S_k+ \sum_{\forall \tau_i \in hp(k)} \left\lceil \frac{t + J_i}{T_i} \right\rceil C_i
\end{equation*} 

%The response time analysis for EDF can be similarly adapted.

\begin{example}
\label{ex:suspension-jitter}    
Consider the fixed-priority task set presented in Table~\ref{table:dynamic-example}. In this case, $\tau_1$ is the highest-priority task and does not self-suspend. Therefore, its WCRT is $R_1 = C_1$ and $J_1 = R_1 - C_1 = 0$. However, the jitter $J_2$ is upper bounded by $D_2 - C_2 =15$. The WCRT of task $\tau_3$ is thus upper bounded by the minimum $t$ larger than $0$ such that 
$$t=C_3+ \sum_{i=1}^2\left\lceil \frac{t + J_i}{T_i} \right\rceil C_i = 1+\left\lceil \frac{t}{2} \right\rceil 1 +\left\lceil \frac{t+15}{20} \right\rceil 5.$$ 
The above equality holds when $t=22$. Therefore, the WCRT of task $\tau_{3}$ is upper bounded by $22$.
\hfill\myendproof  
\end{example}

Note that several solutions proposed in the literature \cite{ECRTS-AudsleyB04,RTAS-AudsleyB04,RTCSA-KimCPKH95} for modeling the 
self-suspending behavior of the interfering tasks as release jitter, are flawed. Those analyses usually assume that $J_i$ can be 
upper-bounded by the total self-suspension time $S_i$ of $\tau_i$. This is usually wrong. A detailed discussion on this matter is 
provided in Section~\ref{sec:wrong-jitter-dynamic}. 

Moreover, we should also note that such a treatment is only valid for
analyzing the worst-case response time for task $\tau_k'$ under the
assumption that $S_k$ is converted into computation, \ie, $C_k'=C_k+S_k$. If the analysis
considers self-suspending behavior of task $\tau_k$, such a
combination in the analysis can be incorrect. For example, in Section~VI of~\cite{ecrts15nelissen},
the higher-priority segmented self-suspending tasks are converted into ordinary sporadic tasks with jitters 
but the suspension time of the task under analysis is not converted into computation. 
We will discuss this misconception in Section~\ref{sec:wrong-jitter-convert-sporadic}.
 



\mysubsection{Modeling self-suspensions as blocking}
\label{sec:model-interfering-blocking}

In her book~\cite[Pages 164-165]{Liu:2000:RS:518501}, Jane W.S. Liu proposed an approach to quantify the interference of
higher-priority tasks by setting up the ``blocking time" induced by the self-suspensions of the interfering tasks on the 
task $\tau_k$ under analysis. This solution, limited to fixed-priority scheduling policies, considers that a job of 
task $\tau_k$ can suffer an extra delay on its completion due to the self-suspending behavior of each task involved in its 
response time. This delay, denoted by $B_k$, is upper bounded by 
\begin{equation*}
B_k=S_k+\sum_{\forall \tau_i \in hp(k)} b_i
\end{equation*}
where (i) $S_k$ accounts for the contribution of the suspension intervals of the task $\tau_k$ under analysis in a similar manner to 
what has already been discussed in Section~\ref{sec:model-interferred-oblivious}, and (ii) $b_i=min(C_i, S_i)$ accounts for the contribution of each higher-priority task $\tau_i$ in $hp(k)$. This equivalent ``blocking time'' $B_k$ can then be used to perform a utilization-based schedulability test. For instance, using the linear-time utilization test by Liu and Layland \cite{Liu_1973} and assuming that the tasks are indexed by the rate monotonic (RM) policy, the condition
\begin{equation*}
\forall k=1,2,\ldots, n,\;\;\;\;\frac{C_k+B_k}{T_k} + \sum_{\forall \tau_i \in hp(k)} U_i \leq k (2^{\frac{1}{k}}-1)
\end{equation*}
is a sufficient schedulability test for implicit-deadline task systems.

This blocking time can also be integrated in the WCRT analysis for fixed-priority scheduling. The WCRT of $\tau_k$ is then given by the least non-negative value $R_k \leq D_k$ such that
\begin{equation*}
R_k = B_k + C_k + \sum_{\forall \tau_i \in hp(k)} \left\lceil \frac{R_k}{T_i} \right\rceil C_i
\end{equation*}


Note that even though \cite{Liu:2000:RS:518501} discusses the intuition behind this modeling strategy, it does not provide any actual proof of its correctness. 
However, the correctness of that approach has been proven in \cite{ChenHuangNelissen,ChenECRTS2016-suspension}. 

\begin{example}
\label{ex:suspension-blocking}    
Consider the task set presented in Table~\ref{table:dynamic-example} to illustrate the above analysis. In this case, $b_1 = 0$ and $b_2 = 5$. Therefore, $B_3 = 5$. So, the worst-case response time of task $\tau_3$ is upper bounded by the minimum $t$ larger than $0$ such that 
\begin{align*}
t & = B_3+C_3+\sum_{i=1}^2 \left\lceil \frac{t}{T_i} \right\rceil C_i = 6+\left\lceil \frac{t}{2} \right\rceil 1 +\left\lceil \frac{t}{20} \right\rceil 5.
\end{align*} 
This equality holds when $t=32$. Therefore, the WCRT of task $\tau_{3}$ is upper bounded by $32$.
\hfill\myendproof  
\end{example}



Devi (in Theorem 8 in \cite[Section 4.5]{DBLP:conf/ecrts/Devi03}) extended the above analysis to
EDF scheduling. However, there is no proof to support the correctness at this moment.


\mysubsection{A Unifying Analysis Framework}
\label{sec:model-interfering-unified}

\begin{table}[t]
\centering
    \begin{tabular}{|c|c|c|c|c|}
 \hline
        & $C_i$ &  $S_i$&  $D_i$ & $T_i$\\ 
        \hline
        $\tau_1$ & 4 & 5 &  10 & 10\\ 
        $\tau_2$ &  6&  1& 19 & 19 \\ 
        $\tau_3$ & 4 & 0  & 50 & 50 \\ 
        \hline
    \end{tabular} 
    \centering
    \renewcommand{\arraystretch}{1.7}
\scalebox{0.9}{
    \begin{tabular}{|c|c|c|}
\hline
    $\vec{x}$ & condition of Eq.~(\ref{eq:TDA-suspension-tighter0}) & upper bound of $R_3$\\
\hline
\hline

Case 1: $(0, 0)$ & $4+ \ceiling{\frac{t+0+5}{10}} 4 + \ceiling{\frac{t+0+9}{19}} 6 \leq t$ & $42$\\ 
\hline
Case 2: $(0, 1)$ &  $4+ \ceiling{\frac{t+1+5}{10}} 4 + \ceiling{\frac{t+1+0}{19}} 6 \leq t$ & $32$\\ 
\hline 
Case 3: $(1, 0)$ & $4+ \ceiling{\frac{t+5+0}{10}} 4 + \ceiling{\frac{t+0+9}{19}} 6 \leq t$ & $42$\\
\hline 
Case 4:$(1, 1)$ & $4+ \ceiling{\frac{t+6+0}{10}} 4 + \ceiling{\frac{t+1+0}{19}}6 \leq t$& $32$\\      
\hline
    \end{tabular}}
% \scalebox{0.6}{
%     \begin{tabular}{|c|c|c|c|c|}
% \hline
%     $\vec{x}$ & Case 1: $(0, 0)$ & Case 2: $(0, 1)$ & Case 3: $(1, 0)$ & Case 4:$(1, 1)$\\
% \hline
% \hline
%     condition of Eq.~(\ref{eq:TDA-suspension-tighter0})& $4+ \ceiling{\frac{t+0+5}{10}} 4 + \ceiling{\frac{t+0+9}{19}} 6 \leq t$ & $4+ \ceiling{\frac{t+1+5}{10}} 4 + \ceiling{\frac{t+1+0}{19}} 6 \leq t$ & $4+ \ceiling{\frac{t+5+0}{10}} 4 + \ceiling{\frac{t+0+9}{19}} 6 \leq t$ & $4+ \ceiling{\frac{t+6+0}{10}} 4 + \ceiling{\frac{t+1+0}{19}}6 \leq t$\\      
% \hline
% upper bound of $R_3$ & $42$ & $32$ & $42$ & $32$\\
% \hline
%     \end{tabular}}
    \caption{A dynamic self-suspending task set used in Example~\ref{ex:rationale_unifying}, originally presented in \cite{ChenECRTS2016-suspension}. Detailed procedure for deriving the upper bound of $R_3$, with $R_1-C_1=5$ and $R_2-C_2=9$.}
    \label{tab:example-unifying-calculation}
  \end{table}

  Suppose that all tasks $\tau_i$ for $1 \leq i \leq k-1$ are
  schedulable under the given fixed-priority scheduling, (\ie, $R_i
  \leq D_i \leq T_i$). In \cite{ChenECRTS2016-suspension}, a unifying framework that dominates the other existing
  schedulability tests and response time analyses for task $\tau_k$ in
  a dynamic self-suspending task system under fixed-priority
  scheduling was proposed. The analysis in \cite{ChenECRTS2016-suspension} is valid
  for any arbitrary vector assignment $\vec{x} = (x_1, x_2, \ldots,
  x_{k-1})$, in which $x_i$ is either $0$ or $1$. The framework
  quantifies the release jitter of task $\tau_i$ in the following
  manner:
  \begin{itemize}
  \item If $x_i$ is $1$ for task $\tau_i$, then the release jitter of
    task $\tau_i$ is $\sum_{j=i}^{k-1} (S_j \times x_j)$. 
  \item If $x_i$ is $0$ for task $\tau_i$, then the release jitter of
    task $\tau_i$ is $(\sum_{j=i}^{k-1} (S_j \times x_j)) + R_i-C_i$. 
  \end{itemize}
  For any given vector assignment $\vec{x}$, the worst-case response
  time $R_k$ of $\tau_k$ is upper bounded by the least non-negative $t
  \leq D_k \leq T_k$ such that
  {\small \begin{equation} \label{eq:TDA-suspension-tighter0} C_k +
      S_k + \sum_{i=1}^{k-1}\ceiling{\frac{t+ (\sum_{j=i}^{k-1} (S_j
          \times x_j))+(1-x_i)(R_i-C_i)}{T_i}} C_i \leq t.
     \end{equation}}

\begin{example} 
\label{ex:rationale_unifying}  
Consider the task set presented in
Table~\ref{tab:example-unifying-calculation}.  By using the same
analysis as in Example~\ref{ex:suspension-jitter}, $R_1=9$ and
$R_2=15$ since $7+\ceiling{\frac{15+5}{10}}4 = 15$.  There are four
possible vector assignments $\vec{x}$ for testing the schedulability
of task $\tau_3$. The corresponding procedure to use these four vector
assignments can be found in
Table~\ref{tab:example-unifying-calculation}.  Case 1 is the same as
the analysis in Section~\ref{sec:model-interfering-jitter} when $J_1 =
R_1-C_1$ and $J_2 = R_2-C_2$.  Among the above four cases, the tests
in Cases 2 and 4 are the tightest.
\hfill\myendproof
\end{example}

The reason for the correctness of the release jitter in
Eq.~(\ref{eq:TDA-suspension-tighter0}) is based on a careful revision
of the critical instant theorem to include the self-suspension time
into the window of interest. The dominance over the
other existing (correct) schedulability tests and response time
analyses was also demonstrated in \cite{ChenECRTS2016-suspension}. To obtain the tightest worst-case response time of task
$\tau_k$, we should consider all the $2^{k-1}$ possible combinations
of $\vec{x}$, implying exponential time complexity. The complexity can
also be reduced by using a linear approximation of the test in
Eq.~(\ref{eq:TDA-suspension-tighter0}) to derive a good vector
assignment in linear time.


\mysubsection{Improving the modeling of segmented self-suspending tasks}
\label{sec:model-interfering-improving}

In the \emph{segmented self-suspending task model}, we can simply ignore the segmentation structure of computation segments and suspension intervals 
and directly apply all the strategies for dynamic self-suspending task models. However, the analysis can become too pessimistic. This is due to the fact 
that the segmented suspensions are not completely dynamic. 

%The static suspension patterns result in also certain (more predictable) suspension patterns. However, characterizing the worst-case 
%suspending patterns of the higher priority tasks to quantify the interference under the segmented self-suspending task model is not easy. 
%Similarly, one possibility is to characterize the worst-case interference in the carry-in job of a higher-priority task $\tau_i$ by analyzing 
%its self-suspending pattern, as presented in \cite{Huang:multiseg}. Another possibility is to  quantify the interference by modeling 
%it with a jitter term, as presented in \cite{RTCSA-BletsasA05}. We will explain later in Section~\ref{sec:wrong-jitter-segmented} 
%why the quantification of the interference in \cite{RTCSA-BletsasA05} is incorrect. {\bf Michael's paper in RTSS1998}. 

%The static suspension patterns result in also certain (more predictable) suspension patterns. 
Characterizing the worst-case 
suspending patterns of the higher-priority tasks to quantify the interference under the segmented self-suspending task model is not easy. 
Modelling the interference by a job of a self-suspending task $\tau_i$ as multiple per-segment ``chunks", spaced apart in time by 
the respective self-suspension intervals in-between, is potentially more accurate than modelling it as a contiguous computation segment of $C_i$ units.
However, the worst-case release offset of $\tau_i$ in $hp(k)$, relative to the task $\tau_k$ under analysis, to maximize the interference needs to be identified.

To deal with this, in \cite{RTCSA-BletsasA05} the computation segments and self-suspension intervals of each interfering task are reordered 
to create a pattern that dominates all such possible task release offsets. The computational segments of the interfering task are modelled 
as distinct tasks arriving at an offset to each other and sharing a period and arrival jitter. However, we will explain in 
Section~\ref{sec:wrong-jitter-segmented} why the quantification of the interference in \cite{RTCSA-BletsasA05} is incorrect. 

Another possibility is to characterize the worst-case interference in the carry-in job of a higher-priority task $\tau_i$ by analyzing 
its self-suspending pattern, as presented in \cite{Huang:multiseg}. This approach does examine the different possible task release offsets
and can also be used for response time analysis compatible with Audsley's optimal priority algorithm~\cite{Audsley1991aOPA}.
Palencia and Gonz\'alez Harbour~\cite{PH:rtss98} provided another technique for modelling the interference of segmented interfering tasks, 
albeit in the context of multiprocessors. %Therefore, this work is discussed later, in Section~\ref{sec:multiprocessor-HRT}.


\mysubsection{Remarks on the Methods without Enforcement}

The strategies presented from Section~\ref{sec:model-interferred-oblivious} to Section~\ref{sec:model-interfering-improving} can be combined together (with care), as shown in Table~\ref{tab:summary-methods}.  These strategies are correct in essence, but the detailed quantifications and combinations should be done carefully to ensure the correctness of the resulting analyses. We will present the corresponding misconceptions due to incorrect quantifications or combinations in \mysectionref{}~\ref{sec:misconceptions}.

\mysection{Period Enforcement Mechanisms}   
\label{sec:release-enforce}

Self-suspension can cause substantial schedulability degradation, because the resulting non-determinism in the schedule can give rise 
to unfavourable execution patterns. To alleviate the potential impact, one possibility is to guarantee periodic behavior by 
enforcing the release time of the computation segments. There exist different categories of such enforcement mechanisms. 


\mysubsection{Dynamic online period enforcement} 
\label{sec:period-enforce}

Rajkumar \cite{Raj:suspension1991} proposed a \emph{period enforcer} 
algorithm to handle the impact of uncertain releases (such as self-suspensions). In a nutshell, the period enforcer algorithm artificially 
increases the length of certain suspensions \emph{dynamically, at run-time},
whenever a task's activation pattern carries the risk of inducing undue interference in 
lower-priority tasks. Quoting \cite{Raj:suspension1991}, the period enforcer algorithm \textit{``forces tasks to behave like ideal 
periodic tasks from the scheduling point of view with no associated scheduling penalties''}. 

The period enforcer has been revisited by Chen and Brandenburg in \cite{ChenBrandenburg}, with the following three observations:
\begin{enumerate}
	\item period enforcement can be a cause of deadline misses for self-suspending task sets that are otherwise schedulable;
	\item with the state-of-the-art techniques, the schedulability analysis of the period enforcer algorithm requires a task set 
	transformation which is subject to exponential time complexity; and 	
    \item the period enforcer algorithm is incompatible with all existing analyses of suspension-based locking protocols, 
	and can in fact cause ever-increasing suspension times until a deadline is missed.
\end{enumerate}

\mysubsection{Static period enforcement} 
\label{sec:static-period-enforce}

As an alternative to the online period enforcement, one may instead achieve periodicity in the activation
of computation segments and prevent the most unfavorable execution patterns from arising, by constraining
each computation segment to be released at a respective \emph{fixed offset} from its job's arrival.
These constant offsets are computed and specified \emph{offline}.
 
Suppose that the offset for the $j$-th computation  segment of task $\tau_i$ is $\phi_i^j$. This means that the 
$j$-th computation segment of task $\tau_i$ is released only at time $r_i+\phi_i^j$, where $r_i$ is the arrival time of a job 
of task $\tau_i$. That is, even if the preceding self-suspension completes before $r_i+\phi_i^j$, the computation segment under 
consideration is never executed earlier. With this static enforcement, each computation segment can be represented by a sporadic 
task with a minimum inter-arrival time $T_i$, a WCET $C_i^j$, and a relative deadline $\phi_{i}^{j+1}-\phi_i^j-S_i^j$ (with 
$\phi_{i}^{m_i+1}$ set to $D_i$).
Suppose that the offset for each computation segment is specified. This can be observed as a reduction to 
the generalized multiframe (GMF) task model introduced in~\cite{baruah1999generalized}. A GMF task $G_i$ consisting of $m_i$ frames is characterized by the $3$-tuple $(\vec{C_i},\vec{D_i},\vec{T_i})$, where $\vec{C_i}$,$\vec{D_i}$, and $\vec{T_i}$ are $m_i$-ary vectors $(C_{i}^0,C_{i}^1,...,C_{i}^{m_i-1})$ of execution requirements, $(D_{i}^0,D_{i}^1,...,D_{i}^{m_i-1})$ of relative deadlines, $(T_{i}^0,T_{i}^1,...,T_{i}^{m_i-1})$ of minimum inter-arrival times, respectively.
In fact, from the analysis perspective, a self-suspending task $\tau_i$ under the offset enforcement is equivalent to a GMF task $G_i$,  by considering the computation segments as the frames with different separation times \cite{WC16-suspend-DATE,DBLP:journals/ieicet/DingTT09}.

Such approaches have been presented in 
\cite{RTSS-KimANR13,RTSS-ChenL14,WC16-suspend-DATE,DBLP:journals/ieicet/DingTT09}. The method in \cite{RTSS-ChenL14} is a simple and greedy solution for 
implicit-deadline self-suspending task systems with at most one self-suspension interval per task. It assigns the 
offset $\phi_i^2$ always to $\frac{T_i+S_i^1}{2}$ and the relative deadline of the first computation segment of task $\tau_i$ to 
$\frac{T_i-S_i^1}{2}$. This is the first method in the literature with \emph{speedup factor} guarantees by using the revised relative 
deadline for earliest-deadline-first scheduling. This has been recently improved 
in \cite{Bruggen16RTNS} based on a simple strategy, called Shortest Execution Interval First Deadline
Assignment (SEIFDA). That is, the tasks are assigned relative deadlines according to a greedy order from the smallest $T_i-S_i$ to the largest $T_i-S_i$.
Moreover, approaches based on Mixed Integer Linear Programming (MILP) were also proposed in \cite{Peng-Fisher-RTCSA2016,Bruggen16RTNS}.
For more than one self-suspension interval per task, Huang and Chen \cite{WC16-suspend-DATE} showed that assigning the relative deadline of each of the computation segments of a task equally also leads to a bounded speedup factor.



The methods in \cite{RTSS-KimANR13,DBLP:journals/ieicet/DingTT09} assign each computation segment a fixed-priority level and an offset. 
Unfortunately,  in \cite{RTSS-KimANR13,DBLP:journals/ieicet/DingTT09}, the schedulability tests are not correct, and the mixed-integer 
linear programming formulation proposed in \cite{RTSS-KimANR13} is unsafe for worst-case response time guarantees. 
A detailed discussion on this matter is 
provided in Section~\ref{sec:wrong-periodic}.

\mysubsection{Slack enforcement} 
\label{sec:slack-enforce}

The slack enforcement in \cite{LR:rtas10} intends to create periodic execution enforcement 
for self-suspending tasks so that a self-suspending task behaves like an ideal periodic task.  However, as to be discussed in 
Section~\ref{sec:open-issues-existing}, the presented methods in \cite{LR:rtas10} require more rigorous proofs to support 
their correctness as the proof of the key lemma of the slack enforcement mechanism in \cite{LR:rtas10} is incomplete.

\mysection{Multiprocessor Scheduling for Self-Suspending Tasks}
\label{sec:multiprocessor-HRT}
  
The schedulability analysis of distributed systems is inherently similar to the schedulability analysis of multiprocessor systems following a 
\emph{partitioned} scheduling scheme. Each task is mapped on one processor and can never migrate to another processor. In~\cite{PH:rtss98}, 
Palencia and Gonz\'alez Harbour extended the worst-case response time analysis for distributed systems, and hence multiprocessor systems, to segmented self-suspending tasks. They model the effect of the self-suspension time as release jitter.
  
The first suspension-aware worst-case response time analysis for dynamic self-suspending sporadic tasks assuming a \emph{global} scheduling scheme was presented in \cite{DBLP:conf/ecrts/LiuA13}. 
The given $M$ processors are assumed to be identical and the jobs can migrate during their execution. The analysis in \cite{DBLP:conf/ecrts/LiuA13} is mainly based on the existing results in the literature for global fixed-priority and earliest deadline first scheduling for sporadic task systems without self-suspensions. The general concept in \cite{DBLP:conf/ecrts/LiuA13} is to quantify the interference from the higher-priority tasks by following similar approaches 
in \cite{baruah2007techniques,DBLP:conf/rtss/GuanSYY09} for task systems without self-suspension. The task that is under analysis greedily uses suspension as computation, as explained in Section~\ref{sec:model-interferred-oblivious}. 

Unfortunately, the schedulability test provided in \cite{DBLP:conf/ecrts/LiuA13} for global fixed-priority scheduling suffers from two errors, which were later fixed in \cite{erratu-cong-anderson}.  Since these two errors are unrelated to any misconception due to self-suspension, we have decided to present them here and not to include them in \mysectionref{}~\ref{sec:misconceptions}.
 First, the workload bound proposed in Lemma~1 (in~\cite{DBLP:conf/ecrts/LiuA13}) is unsafe. It has been acknowledged and corrected in \cite{erratu-cong-anderson}. 
Secondly, it is optimistic to claim that there are at most $M-1$ carry-in jobs in the general case. This flaw has been inherited from an error in  
previous work \cite{DBLP:conf/rtss/GuanSYY09}, which was pointed out and further corrected in \cite{sun2014improving,DBLP:conf/rtns/HuangC15}.  Therefore, by adopting the analysis from \cite{DBLP:conf/rtns/HuangC15}, which is consistent with the analysis in \cite{DBLP:conf/ecrts/LiuA13}, the problem can easily be fixed. The reader is referred to \cite{erratu-cong-anderson} for further details.
 
The authors of \cite{dong-liu-RTSS2016} explored global earliest-deadline-first (global EDF) scheduling for dynamic self-suspending tasks. They presented an approach to selectively convert the self-suspension time of a few tasks into computation and performed the schedulability tests purely based on the utilization of the computation after conversion.
In \cite{ChenHLRTSS2015}, the authors studied global rate-monotonic scheduling in multiprocessor systems, including dynamic self-suspending tasks. The proposed utilization-based schedulability analysis  can easily be extended to handle constrained-deadline task systems and any given fixed-priority assignment.
  
  


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "JRTS/JRTS.tex"
%%% End:


  
